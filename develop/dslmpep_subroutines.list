MODULE dslmpep_subroutines

IMPLICIT NONE
!parameters
INTEGER, PARAMETER :: dp=KIND(0.0D0), itmax=50
REAL(dp), PARAMETER :: eps=EPSILON(0.0_dp), big=HUGE(0.0_dp)
REAL(dp), PARAMETER :: zero=0.0_dp, one=1.0_dp
COMPLEX(dp), PARAMETER :: czero=DCMPLX(zero), cone=DCMPLX(one)

CONTAINS

!************************************************************************
!			SUBROUTINE DSLCORR				*
!************************************************************************
! Compute the Laguerre correction term for scalar polynomial p with real*
! coeffs of degree d at real number (tr,0). The magnitude of the	*
! coeffs are stored in alpha, all n previously found roots are stored	*
! in (er,ei). Result is returned in complex number (tr,ti), and backward*
! error of current approximation is stored in be.			*
!************************************************************************
SUBROUTINE dslcorr(p, alpha, er, ei, berr, tol, check, d, i)
IMPLICIT NONE
!scalar arguments
LOGICAL, INTENT(INOUT) :: check
INTEGER, INTENT(IN) :: d, i
REAL(dp), INTENT(IN) :: tol
REAL(dp), INTENT(INOUT) :: berr
!array arguments
REAL(dp), INTENT(IN) :: p(*), alpha(*)
REAL(dp), INTENT(INOUT) :: er(*), ei(*)
!local scalars
INTEGER :: k
REAL(dp) :: a, b, c, t
DOUBLE COMPLEX :: x1, x2, y1, y2
!intrinsic procedures
INTRINSIC :: DABS, DBLE, DCMPLX, DIMAG, ZABS, ZSQRT

!initiate variables
x1=czero; x2=czero
DO k=1,i-1
  y1=1/DCMPLX(er(i)-er(k),-ei(k))
  x1=x1+y1
  x2=x2+y1**2
ENDDO
t=er(i)
!split into 2 cases
IF(DABS(t)>1) THEN
  !compute a=revp, berr
  t=1/t
  CALL drevseval(p, t, a, d, 0)
  CALL drevseval(alpha, DABS(t), berr, d, 0)
  berr=MIN(DABS(a)/berr, DABS(a))
  IF(berr<eps) THEN
    ei(i)=zero
    check=.TRUE.
    RETURN
  ELSE
    !compute b=revp', c=revp''
    CALL drevseval(p, t, b, d, 1)
    CALL drevseval(p, t, c, d, 2)
    !compute y1=p'/p and y2=(p'/p)'
    y1=t*(d-t*(b/a))
    y2=t**2*(d-2*t*(b/a)+t**2*((b/a)**2-c/a))
  ENDIF
ELSE
  !compute a=p, berr
  CALL dseval(p, t, a, d, 0)
  CALL dseval(alpha, DABS(t), berr, d, 0)
  berr=MIN(DABS(a)/berr, DABS(a))
  IF(berr<eps) THEN
    ei(i)=zero
    check=.TRUE.
    RETURN
  ELSE
    !compute b=p', c=p''
    CALL dseval(p, t, b, d, 1)
    CALL dseval(p, t, c, d, 2)
    !compute y1=p'/p and y2=(p'/p)'
    y1=b/a
    y2=y1**2-c/a
  ENDIF
ENDIF
!remove previously found roots
x1=y1-x1
x2=y2-x2
k=d-i+1
!denominator of Laguerre correction term
y1=ZSQRT((k-1)*(k*x2-x1**2))
y2=x1-y1; y1=x1+y1
IF(ZABS(y1)>=ZABS(y2)) THEN
  y1=k/y1
  IF(ZABS(y1)<tol) THEN
    ei(i)=zero
    check=.TRUE.
  ELSE
    er(i)=er(i)-DBLE(y1)
    ei(i)=-DIMAG(y1)
  ENDIF
ELSE
  y2=k/y2
  IF(ZABS(y2)<tol) THEN
    ei(i)=zero
    check=.TRUE.
  ELSE
    er(i)=er(i)-DBLE(y2)
    ei(i)=-DIMAG(y2)
  ENDIF
ENDIF
RETURN
END SUBROUTINE dslcorr

!************************************************************************
!			SUBROUTINE ZSLCORR				*
!************************************************************************
! Compute the Laguerre correction term for scalar polynomial p with real*
! coeffs of degree d at complex number (tr,ti). The magnitude of the	*
! coeffs are stored in alpha, all n previously found roots are stored	*
! in (er,ei). Result is return in complex number (tr,ti), and backward	*
! error of current approximation is stored in be.			*
!************************************************************************
SUBROUTINE zslcorr(p, alpha, er, ei, berr, tol, check, d, i)
IMPLICIT NONE
!scalar arguments
LOGICAL, INTENT(INOUT) :: check
INTEGER, INTENT(IN) :: d, i
REAL(dp), INTENT(IN) :: tol
REAL(dp), INTENT(INOUT) :: berr
!array arguments
REAL(dp), INTENT(IN) :: p(*), alpha(*)
REAL(dp), INTENT(INOUT) :: er(*), ei(*)
!local scalars
INTEGER :: k
COMPLEX(dp) :: a, b, c, t, x1, x2, y1, y2
!intrinsic procedures
INTRINSIC :: DBLE, DCMPLX, DIMAG, ZABS, ZSQRT

!initiate variables
x1=czero; x2=czero
DO k=1,i-1
  y1=1/DCMPLX(er(i)-er(k),ei(i)-ei(k))
  x1=x1+y1
  x2=x2+y1**2
ENDDO
t=DCMPLX(er(i),ei(i))
!split into 2 cases
IF(ZABS(t)>1) THEN
  !compute a=revp, berr
  t=1/t
  CALL zrevseval(p, t, a, d, 0)
  CALL drevseval(alpha, ZABS(t), berr, d, 0)
  berr=MIN(ZABS(a)/berr, ZABS(a))
  IF(berr<eps) THEN
    check=.TRUE.
    RETURN
  ELSE
    !compute b=revp', c=revp''
    CALL zrevseval(p, t, b, d, 1)
    CALL zrevseval(p, t, c, d, 2)
    !compute y1=p'/p and y2=(p'/p)'
    y1=t*(d-t*(b/a))
    y2=t**2*(d-2*t*(b/a)+t**2*((b/a)**2-c/a))
  ENDIF
ELSE
  !compute a=p, berr
  CALL zseval(p, t, a, d, 0)
  CALL dseval(alpha, ZABS(t), berr, d, 0)
  berr=MIN(ZABS(a)/berr, ZABS(a))
  IF(berr<eps) THEN
    check=.TRUE.
    RETURN
  ELSE
    !solve for b=p', c=p''
    CALL zseval(p, t, b, d, 1)
    CALL zseval(p, t, c, d, 2)
    !compute y1=p'/p and y2=(p'/p)'
    y1=b/a
    y2=y1**2-c/a
  ENDIF
ENDIF
!remove previously found roots
x1=y1-x1
x2=y2-x2
k=d-i+1
!denominator of Laguerre correction term
y1=ZSQRT((k-1)*(k*x2-x1**2))
y2=x1-y1; y1=x1+y1
IF(ZABS(y1)>=ZABS(y2)) THEN
  y1=k/y1
  IF(ZABS(y1)<tol) THEN
    check=.TRUE.
  ELSE
    er(i)=er(i)-DBLE(y1)
    ei(i)=ei(i)-DIMAG(y1)
  ENDIF
ELSE
  y2=k/y2
  IF(ZABS(y2)<tol) THEN
    check=.TRUE.
  ELSE
    er(i)=er(i)-DBLE(y2)
    ei(i)=ei(i)-DIMAG(y2)
  ENDIF
ENDIF
RETURN
END SUBROUTINE zslcorr

!************************************************************************
!			SUBROUTINE DREVSEVAL				*
!************************************************************************
! Evaluate reversal of scalar polynomial p with real coeffs of degree d,*
! and its der=0,1,2 derivatives at real number 1/t, where |t|>1. 	*
! Returns evaluation in a.						*
!************************************************************************
SUBROUTINE drevseval(p, t, a, d, der)
IMPLICIT NONE
!scalar arguments
INTEGER, INTENT(IN) :: d, der
REAL(dp), INTENT(IN) :: t
REAL(dp), INTENT(INOUT) :: a
!array arguments
REAL(dp), INTENT(IN) :: p(*)
!local scalars
INTEGER :: k

IF(der==0) THEN
  a=p(1)
  DO k=2,d+1
    a=t*a+p(k)
  ENDDO
ELSEIF(der==1) THEN
  a=d*p(1)
  DO k=2,d
    a=t*a+(d-k+1)*p(k)
  ENDDO
ELSE
  a=d*(d-1)*p(1)
  DO k=2,d-1
    a=t*a+(d-k+1)*(d-k)*p(k)
  ENDDO
ENDIF
RETURN
END SUBROUTINE drevseval



!************************************************************************
!			SUBROUTINE ZREVSEVAL				*
!************************************************************************
! Evaluate reversal of scalar polynomial p with real coeffs of degree d,*
! and its der=0,1,2 derivatives at complex number 1/t, where |t|>1. 	*
! Returns evaluation in a.						*
!************************************************************************
SUBROUTINE zrevseval(p, t, a, d, der)
IMPLICIT NONE
!scalar arguments
INTEGER, INTENT(IN) :: d, der
COMPLEX(dp), INTENT(IN) :: t
COMPLEX(dp), INTENT(INOUT) :: a
!array arguments
REAL(dp), INTENT(IN) :: p(*)
!local scalars
INTEGER :: k

IF(der==0) THEN
  a=p(1)
  DO k=2,d+1
    a=t*a+p(k)
  ENDDO
ELSEIF(der==1) THEN
  a=d*p(1)
  DO k=2,d
    a=t*a+(d-k+1)*p(k)
  ENDDO
ELSE
  a=d*(d-1)*P(1)
  DO k=2,d-1
    a=t*a+(d-k+1)*(d-k)*p(k)
  ENDDO
ENDIF
RETURN
END SUBROUTINE zrevseval


!************************************************************************
!			SUBROUTINE DSSTART				*
!************************************************************************
! Compute the initial esimates of the roots of a real scalar polynomial *
! using the Newton Polygon method. The absolute value of the 		*
! coefficients of the polynomial of degree d are stored in alpha, the 	*
! real and imaginary parts of the initial estiamtes are returned in er 	*
! and ei.         							*
!************************************************************************
SUBROUTINE dsstart(alpha, er, ei, d)
IMPLICIT NONE
!scalar arguments
INTEGER, INTENT(IN) :: d
!array arguments
REAL(dp), INTENT(IN) :: alpha(*)
REAL(dp), INTENT(INOUT) :: er(*), ei(*)
!parameters
REAL(dp), PARAMETER :: pi2 = 6.2831853071795865_dp, sigma = 0.7_dp
!local scalars
INTEGER :: c, i, iold, j, nzeros
REAL(dp) :: ang, r, th
!local arrays
LOGICAL, DIMENSION(d+1) :: h
REAL(dp), DIMENSION(d+1) :: a
!intrinsic procedures
INTRINSIC :: DCOS, DEXP, DLOG, DSIN

!compute log(alpha)
DO i=1,d+1
  IF(alpha(i)>=eps) THEN
    a(i)=DLOG(alpha(i))
  ELSE
    a(i)=-one
  ENDIF
ENDDO
!compute upper convex hull
CALL cnvex(d+1,a,h)
!compute initial estimates
iold=1; c=0; th=pi2/d
DO i=2,d+1
  IF(h(i)) THEN
    nzeros=i-iold
    r=DEXP((a(iold)-a(i))/nzeros)
    ang=pi2/nzeros
    DO j=1,nzeros
      er(c+j)=r*DCOS(ang*j+th*i+sigma)
      ei(c+j)=r*DSIN(ang*j+th*i+sigma)
    ENDDO
    c=c+nzeros
    iold=i
  ENDIF
ENDDO
RETURN
END SUBROUTINE dsstart

END MODULE dslmpep_subroutines
